/**
 * Solve Comment Parser
 *
 * Detects and parses /solve command output from GitHub issue comments.
 * When a solve comment exists, its phase recommendations take precedence
 * over content analysis (but not over labels).
 *
 * @example
 * ```typescript
 * import { findSolveComment, parseSolveWorkflow } from './solve-comment-parser';
 *
 * const comments = [
 *   { body: "Some regular comment" },
 *   { body: "## Solve Workflow for Issues: 123\n..." },
 * ];
 *
 * const solveComment = findSolveComment(comments);
 * if (solveComment) {
 *   const phases = parseSolveWorkflow(solveComment.body);
 *   // phases: { phases: ['spec', 'exec', 'test', 'qa'], qualityLoop: false }
 * }
 * ```
 */

import type { Phase } from "./workflow/types.js";
import type { PhaseSignal } from "./phase-signal.js";

/**
 * Result of parsing a solve comment
 */
export interface SolveWorkflowResult {
  /** Phases recommended by solve */
  phases: Phase[];
  /** Whether quality loop is recommended */
  qualityLoop: boolean;
  /** The issue numbers mentioned in the solve comment */
  issueNumbers: number[];
  /** Raw workflow string (e.g., "spec ‚Üí exec ‚Üí test ‚Üí qa") */
  workflowString?: string;
}

/**
 * Comment structure (simplified from GitHub API)
 */
export interface IssueComment {
  body: string;
  author?: {
    login: string;
  };
  createdAt?: string;
}

/**
 * Markers that indicate a solve comment
 */
const SOLVE_MARKERS = [
  "## Solve Analysis",
  "## Solve Workflow for Issues:",
  "## Solve Workflow for Issue:",
  "### Recommended Workflow",
  "*üìù Generated by `/solve",
];

/**
 * Pattern to extract phases from solve workflow
 * Matches: `/spec`, `/exec`, `/test`, `/qa`, etc.
 * Also matches without slash: `spec`, `exec`, `test`, `qa` (for arrow notation)
 */
const PHASE_PATTERN =
  /\/?(?<!\w)(spec|exec|test|qa|security-review|testgen|loop)(?!\w)/g;

/**
 * Pattern to detect quality loop recommendation
 */
const QUALITY_LOOP_PATTERNS = [
  /quality\s*loop.*auto-enable/i,
  /--quality-loop/i,
  /quality\s*loop.*recommended/i,
  /enable.*quality\s*loop/i,
];

/**
 * Pattern to extract structured data from HTML comment markers
 * Matches: <!-- solve:phases=exec,qa -->
 */
const SOLVE_HTML_MARKER_PATTERN = /<!--\s*solve:(\w[\w-]*)=([\w,.-]+)\s*-->/g;

/**
 * Pattern to extract issue numbers from solve header
 * Matches: "## Solve Workflow for Issues: 123, 456"
 */
const ISSUE_NUMBER_PATTERN = /#?(\d+)/g;

/**
 * Check if a comment is a solve command output
 *
 * @param body - The comment body
 * @returns True if this appears to be a solve comment
 */
export function isSolveComment(body: string): boolean {
  return SOLVE_MARKERS.some((marker) => body.includes(marker));
}

/**
 * Find the most recent solve comment from a list of comments
 *
 * @param comments - Array of issue comments
 * @returns The solve comment if found, null otherwise
 */
export function findSolveComment(
  comments: IssueComment[],
): IssueComment | null {
  // Search from most recent to oldest (assuming comments are in chronological order)
  for (let i = comments.length - 1; i >= 0; i--) {
    if (isSolveComment(comments[i].body)) {
      return comments[i];
    }
  }
  return null;
}

/**
 * Parse phases from a solve workflow string
 *
 * @param workflowString - String like "spec ‚Üí exec ‚Üí test ‚Üí qa"
 * @returns Array of phases
 */
function parseWorkflowString(workflowString: string): Phase[] {
  const phases: Phase[] = [];
  const matches = workflowString.matchAll(PHASE_PATTERN);

  for (const match of matches) {
    const phase = match[1] as Phase;
    if (!phases.includes(phase)) {
      phases.push(phase);
    }
  }

  return phases;
}

/**
 * Structured data extracted from HTML comment markers in solve comments
 */
export interface SolveMarkers {
  /** Recommended phases (from <!-- solve:phases=... -->) */
  phases?: string[];
  /** Whether to skip spec (from <!-- solve:skip-spec=... -->) */
  skipSpec?: boolean;
  /** Whether browser testing is needed (from <!-- solve:browser-test=... -->) */
  browserTest?: boolean;
  /** Whether quality loop is recommended (from <!-- solve:quality-loop=... -->) */
  qualityLoop?: boolean;
}

/**
 * Parse HTML comment markers from a solve comment body
 *
 * Extracts structured data from markers like:
 * - `<!-- solve:phases=exec,qa -->`
 * - `<!-- solve:skip-spec=true -->`
 * - `<!-- solve:browser-test=false -->`
 * - `<!-- solve:quality-loop=true -->`
 *
 * @param body - The comment body
 * @returns Parsed markers
 */
export function parseSolveMarkers(body: string): SolveMarkers {
  const markers: SolveMarkers = {};
  const matches = body.matchAll(SOLVE_HTML_MARKER_PATTERN);

  for (const match of matches) {
    const key = match[1];
    const value = match[2];

    switch (key) {
      case "phases":
        markers.phases = value.split(",").filter(Boolean);
        break;
      case "skip-spec":
        markers.skipSpec = value === "true";
        break;
      case "browser-test":
        markers.browserTest = value === "true";
        break;
      case "quality-loop":
        markers.qualityLoop = value === "true";
        break;
    }
  }

  return markers;
}

/**
 * Parse a solve comment to extract workflow information
 *
 * @param body - The solve comment body
 * @returns Parsed workflow result
 */
export function parseSolveWorkflow(body: string): SolveWorkflowResult {
  const result: SolveWorkflowResult = {
    phases: [],
    qualityLoop: false,
    issueNumbers: [],
  };

  // Extract issue numbers from header (both old and new formats)
  const headerMatch = body.match(
    /## Solve (?:Workflow for Issues?|Analysis)(?::\s*|\s+for\s+)([^\n]+)/i,
  );
  if (headerMatch) {
    const numberMatches = headerMatch[1].matchAll(ISSUE_NUMBER_PATTERN);
    for (const match of numberMatches) {
      const num = parseInt(match[1], 10);
      if (!isNaN(num) && !result.issueNumbers.includes(num)) {
        result.issueNumbers.push(num);
      }
    }
  }

  // Try HTML comment markers first (most reliable, machine-readable)
  const markers = parseSolveMarkers(body);
  if (markers.phases && markers.phases.length > 0) {
    result.phases = markers.phases as Phase[];
    result.workflowString = markers.phases.join(" ‚Üí ");
  }

  if (markers.qualityLoop !== undefined) {
    result.qualityLoop = markers.qualityLoop;
  }

  // If we got phases from markers, we're done
  if (result.phases.length > 0) {
    return result;
  }

  // Find workflow lines (e.g., "/spec 152" or "spec ‚Üí exec ‚Üí qa")
  const lines = body.split("\n");

  // First pass: look for arrow notation (most reliable)
  for (const line of lines) {
    if (line.includes("‚Üí") || line.includes("->")) {
      const phases = parseWorkflowString(line);
      if (phases.length > 0) {
        result.phases = phases;
        result.workflowString = line.trim();
        break;
      }
    }
  }

  // Second pass: if no arrow notation found, collect phases from multiple lines
  if (result.phases.length === 0) {
    const collectedPhases: Phase[] = [];

    for (const line of lines) {
      // Look for slash command patterns on individual lines
      if (
        line.includes("/spec") ||
        line.includes("/exec") ||
        line.includes("/test") ||
        line.includes("/qa")
      ) {
        const linePhases = parseWorkflowString(line);
        for (const phase of linePhases) {
          if (!collectedPhases.includes(phase)) {
            collectedPhases.push(phase);
          }
        }
      }
    }

    if (collectedPhases.length > 0) {
      result.phases = collectedPhases;
      result.workflowString = collectedPhases.map((p) => `/${p}`).join(" ‚Üí ");
    }
  }

  // If no phases found from lines, try full body
  if (result.phases.length === 0) {
    result.phases = parseWorkflowString(body);
  }

  // Check for quality loop recommendation (if not already set by markers)
  if (!result.qualityLoop) {
    for (const pattern of QUALITY_LOOP_PATTERNS) {
      if (pattern.test(body)) {
        result.qualityLoop = true;
        break;
      }
    }
  }

  return result;
}

/**
 * Convert solve workflow result to phase signals
 *
 * @param workflow - The parsed solve workflow
 * @returns Array of phase signals with 'solve' source
 */
export function solveWorkflowToSignals(
  workflow: SolveWorkflowResult,
): PhaseSignal[] {
  const signals: PhaseSignal[] = [];

  for (const phase of workflow.phases) {
    signals.push({
      phase,
      source: "solve",
      confidence: "high",
      reason: `Recommended by /solve command: ${workflow.workflowString || phase}`,
    });
  }

  if (workflow.qualityLoop) {
    signals.push({
      phase: "quality-loop",
      source: "solve",
      confidence: "high",
      reason: "Quality loop recommended by /solve command",
    });
  }

  return signals;
}

/**
 * Check if solve comment covers the current issue
 *
 * @param workflow - The parsed solve workflow
 * @param issueNumber - The current issue number
 * @returns True if the solve comment includes this issue
 */
export function solveCoversIssue(
  workflow: SolveWorkflowResult,
  issueNumber: number,
): boolean {
  return workflow.issueNumbers.includes(issueNumber);
}
