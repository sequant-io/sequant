import { describe, it, expect } from "vitest";
import {
  isSolveComment,
  findSolveComment,
  parseSolveMarkers,
  parseSolveWorkflow,
  solveWorkflowToSignals,
  solveCoversIssue,
  type IssueComment,
} from "./solve-comment-parser.js";

describe("solve-comment-parser", () => {
  describe("isSolveComment", () => {
    it("should detect solve workflow header", () => {
      const body = `## Solve Workflow for Issues: 123

### Recommended Workflow
...`;

      expect(isSolveComment(body)).toBe(true);
    });

    it("should detect single issue variant", () => {
      const body = `## Solve Workflow for Issue: 456

...`;

      expect(isSolveComment(body)).toBe(true);
    });

    it("should detect generator signature", () => {
      const body = `Some content

*ðŸ“ Generated by \`/solve 123\`*`;

      expect(isSolveComment(body)).toBe(true);
    });

    it("should detect ## Solve Analysis marker", () => {
      const body = `## Solve Analysis

**Recommended Phases:** exec â†’ qa
**Skip Spec:** Yes

<!-- solve:phases=exec,qa -->`;

      expect(isSolveComment(body)).toBe(true);
    });

    it("should return false for regular comments", () => {
      expect(isSolveComment("Just a regular comment")).toBe(false);
      expect(isSolveComment("## Some other heading")).toBe(false);
    });
  });

  describe("findSolveComment", () => {
    it("should find solve comment in array", () => {
      const comments: IssueComment[] = [
        { body: "Regular comment 1" },
        { body: "## Solve Workflow for Issues: 123\n..." },
        { body: "Regular comment 2" },
      ];

      const found = findSolveComment(comments);

      expect(found).toBeDefined();
      expect(found?.body).toContain("Solve Workflow");
    });

    it("should return most recent solve comment", () => {
      const comments: IssueComment[] = [
        { body: "## Solve Workflow for Issues: 123\nOld" },
        { body: "Regular comment" },
        { body: "## Solve Workflow for Issues: 456\nNew" },
      ];

      const found = findSolveComment(comments);

      expect(found?.body).toContain("456");
    });

    it("should return null when no solve comment exists", () => {
      const comments: IssueComment[] = [
        { body: "Regular comment 1" },
        { body: "Regular comment 2" },
      ];

      expect(findSolveComment(comments)).toBeNull();
    });

    it("should handle empty array", () => {
      expect(findSolveComment([])).toBeNull();
    });
  });

  describe("parseSolveWorkflow", () => {
    it("should extract issue numbers from header", () => {
      const body = `## Solve Workflow for Issues: 123, 456

...`;

      const result = parseSolveWorkflow(body);

      expect(result.issueNumbers).toContain(123);
      expect(result.issueNumbers).toContain(456);
    });

    it("should extract issue numbers with # prefix", () => {
      const body = `## Solve Workflow for Issues: #123, #456

...`;

      const result = parseSolveWorkflow(body);

      expect(result.issueNumbers).toContain(123);
      expect(result.issueNumbers).toContain(456);
    });

    it("should parse phases from arrow notation", () => {
      const body = `## Solve Workflow for Issues: 123

### Recommended Workflow

\`\`\`
/spec â†’ /exec â†’ /test â†’ /qa
\`\`\``;

      const result = parseSolveWorkflow(body);

      expect(result.phases).toEqual(["spec", "exec", "test", "qa"]);
    });

    it("should parse phases from ASCII arrow notation", () => {
      const body = `spec -> exec -> qa`;

      const result = parseSolveWorkflow(body);

      expect(result.phases).toContain("spec");
      expect(result.phases).toContain("exec");
      expect(result.phases).toContain("qa");
    });

    it("should parse phases from slash command lines", () => {
      const body = `**For #123:**
\`\`\`bash
/spec 123
/exec 123
/qa 123
\`\`\``;

      const result = parseSolveWorkflow(body);

      expect(result.phases).toContain("spec");
      expect(result.phases).toContain("exec");
      expect(result.phases).toContain("qa");
    });

    it("should detect quality loop recommendation", () => {
      const body = `## Solve Workflow for Issues: 123

> **Note:** Issue #123 has \`refactor\` label. Quality loop will **auto-enable** when using \`sequant run\`.`;

      const result = parseSolveWorkflow(body);

      expect(result.qualityLoop).toBe(true);
    });

    it("should detect --quality-loop flag mention", () => {
      const body = `Run with quality loop:
\`\`\`bash
npx sequant run 123 --quality-loop
\`\`\``;

      const result = parseSolveWorkflow(body);

      expect(result.qualityLoop).toBe(true);
    });

    it("should handle security-review phase", () => {
      const body = `/spec â†’ /exec â†’ /security-review â†’ /qa`;

      const result = parseSolveWorkflow(body);

      expect(result.phases).toContain("security-review");
    });

    it("should deduplicate phases", () => {
      const body = `/spec 123
/exec 123
/spec 456
/exec 456`;

      const result = parseSolveWorkflow(body);

      const specCount = result.phases.filter((p) => p === "spec").length;
      expect(specCount).toBe(1);
    });

    it("should return empty result for non-solve content", () => {
      const result = parseSolveWorkflow("Just regular text");

      expect(result.phases).toHaveLength(0);
      expect(result.qualityLoop).toBe(false);
      expect(result.issueNumbers).toHaveLength(0);
    });

    it("should parse new ## Solve Analysis format with HTML markers", () => {
      const body = `## Solve Analysis

**Recommended Phases:** exec â†’ qa
**Skip Spec:** Yes (trivial fix)
**Browser Testing:** No
**Quality Loop:** No

### Reasoning
- Title contains "Fix unused variable"

<!-- solve:phases=exec,qa -->
<!-- solve:skip-spec=true -->
<!-- solve:browser-test=false -->
<!-- solve:quality-loop=false -->`;

      const result = parseSolveWorkflow(body);

      expect(result.phases).toEqual(["exec", "qa"]);
      expect(result.qualityLoop).toBe(false);
      expect(result.workflowString).toBe("exec â†’ qa");
    });

    it("should prefer HTML markers over arrow notation", () => {
      const body = `## Solve Analysis

**Recommended Phases:** spec â†’ exec â†’ test â†’ qa

<!-- solve:phases=exec,qa -->`;

      const result = parseSolveWorkflow(body);

      // HTML markers take precedence
      expect(result.phases).toEqual(["exec", "qa"]);
    });

    it("should parse quality loop from HTML markers", () => {
      const body = `## Solve Analysis

<!-- solve:phases=spec,exec,qa -->
<!-- solve:quality-loop=true -->`;

      const result = parseSolveWorkflow(body);

      expect(result.phases).toEqual(["spec", "exec", "qa"]);
      expect(result.qualityLoop).toBe(true);
    });

    it("should find solve comment with ## Solve Analysis", () => {
      const comments: IssueComment[] = [
        { body: "Regular comment" },
        { body: "## Solve Workflow for Issues: 100\nspec â†’ exec â†’ qa" },
        {
          body: "## Solve Analysis\n\nexec â†’ qa\n<!-- solve:phases=exec,qa -->",
        },
      ];

      const found = findSolveComment(comments);

      expect(found).toBeDefined();
      expect(found?.body).toContain("## Solve Analysis");
    });
  });

  describe("parseSolveMarkers", () => {
    it("should parse phases marker", () => {
      const body = "<!-- solve:phases=exec,qa -->";
      const markers = parseSolveMarkers(body);
      expect(markers.phases).toEqual(["exec", "qa"]);
    });

    it("should parse all markers", () => {
      const body = `<!-- solve:phases=spec,exec,test,qa -->
<!-- solve:skip-spec=false -->
<!-- solve:browser-test=true -->
<!-- solve:quality-loop=true -->`;

      const markers = parseSolveMarkers(body);

      expect(markers.phases).toEqual(["spec", "exec", "test", "qa"]);
      expect(markers.skipSpec).toBe(false);
      expect(markers.browserTest).toBe(true);
      expect(markers.qualityLoop).toBe(true);
    });

    it("should handle skip-spec=true", () => {
      const markers = parseSolveMarkers("<!-- solve:skip-spec=true -->");
      expect(markers.skipSpec).toBe(true);
    });

    it("should return empty object for no markers", () => {
      const markers = parseSolveMarkers("No markers here");
      expect(markers.phases).toBeUndefined();
      expect(markers.skipSpec).toBeUndefined();
    });

    it("should handle markers with extra whitespace", () => {
      const markers = parseSolveMarkers("<!--  solve:phases=exec,qa  -->");
      expect(markers.phases).toEqual(["exec", "qa"]);
    });

    it("should ignore unknown marker keys", () => {
      const markers = parseSolveMarkers("<!-- solve:unknown-key=value -->");
      expect(markers.phases).toBeUndefined();
      expect(markers.skipSpec).toBeUndefined();
    });
  });

  describe("solveWorkflowToSignals", () => {
    it("should convert phases to signals", () => {
      const workflow = {
        phases: ["spec" as const, "exec" as const, "test" as const],
        qualityLoop: false,
        issueNumbers: [123],
        workflowString: "spec â†’ exec â†’ test",
      };

      const signals = solveWorkflowToSignals(workflow);

      expect(signals).toHaveLength(3);
      expect(signals).toContainEqual(
        expect.objectContaining({
          phase: "spec",
          source: "solve",
          confidence: "high",
        }),
      );
    });

    it("should add quality-loop signal when enabled", () => {
      const workflow = {
        phases: ["spec" as const, "exec" as const],
        qualityLoop: true,
        issueNumbers: [123],
      };

      const signals = solveWorkflowToSignals(workflow);

      expect(signals).toContainEqual(
        expect.objectContaining({
          phase: "quality-loop",
          source: "solve",
          confidence: "high",
        }),
      );
    });

    it("should include workflow string in reason", () => {
      const workflow = {
        phases: ["test" as const],
        qualityLoop: false,
        issueNumbers: [123],
        workflowString: "spec â†’ exec â†’ test â†’ qa",
      };

      const signals = solveWorkflowToSignals(workflow);

      expect(signals[0].reason).toContain("spec â†’ exec â†’ test â†’ qa");
    });
  });

  describe("solveCoversIssue", () => {
    it("should return true when issue is in workflow", () => {
      const workflow = {
        phases: ["spec" as const],
        qualityLoop: false,
        issueNumbers: [123, 456],
      };

      expect(solveCoversIssue(workflow, 123)).toBe(true);
      expect(solveCoversIssue(workflow, 456)).toBe(true);
    });

    it("should return false when issue is not in workflow", () => {
      const workflow = {
        phases: ["spec" as const],
        qualityLoop: false,
        issueNumbers: [123],
      };

      expect(solveCoversIssue(workflow, 789)).toBe(false);
    });
  });
});
