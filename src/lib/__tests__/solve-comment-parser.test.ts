import { describe, it, expect } from "vitest";
import {
  isSolveComment,
  findSolveComment,
  parseSolveWorkflow,
  solveWorkflowToSignals,
  solveCoversIssue,
  type IssueComment,
} from "../solve-comment-parser.js";

describe("solve-comment-parser", () => {
  describe("isSolveComment", () => {
    it("detects solve workflow header with multiple issues", () => {
      expect(isSolveComment("## Solve Workflow for Issues: 123, 456")).toBe(
        true,
      );
    });

    it("detects solve workflow header with single issue", () => {
      expect(isSolveComment("## Solve Workflow for Issue: 123")).toBe(true);
    });

    it("detects recommended workflow section", () => {
      expect(isSolveComment("### Recommended Workflow\nspec â†’ exec â†’ qa")).toBe(
        true,
      );
    });

    it("detects generated by marker", () => {
      expect(isSolveComment("*ðŸ“ Generated by `/solve` command*")).toBe(true);
    });

    it("returns false for regular comments", () => {
      expect(isSolveComment("This is a regular comment")).toBe(false);
      expect(isSolveComment("## Implementation Plan")).toBe(false);
    });
  });

  describe("findSolveComment", () => {
    it("returns null for empty array", () => {
      expect(findSolveComment([])).toBeNull();
    });

    it("returns null when no solve comment exists", () => {
      const comments: IssueComment[] = [
        { body: "Regular comment 1" },
        { body: "Regular comment 2" },
      ];
      expect(findSolveComment(comments)).toBeNull();
    });

    it("finds solve comment", () => {
      const comments: IssueComment[] = [
        { body: "Regular comment" },
        { body: "## Solve Workflow for Issues: 123\nspec â†’ exec â†’ qa" },
      ];
      const result = findSolveComment(comments);
      expect(result).not.toBeNull();
      expect(result?.body).toContain("Solve Workflow");
    });

    it("returns most recent solve comment when multiple exist", () => {
      const comments: IssueComment[] = [
        { body: "## Solve Workflow for Issues: 100\nspec â†’ exec" },
        { body: "Regular comment" },
        { body: "## Solve Workflow for Issues: 200\nspec â†’ exec â†’ test â†’ qa" },
      ];
      const result = findSolveComment(comments);
      expect(result?.body).toContain("200");
    });
  });

  describe("parseSolveWorkflow", () => {
    describe("phase extraction", () => {
      it("parses arrow notation phases", () => {
        const body = "## Solve Workflow for Issues: 123\nspec â†’ exec â†’ qa";
        const result = parseSolveWorkflow(body);
        expect(result.phases).toEqual(["spec", "exec", "qa"]);
        expect(result.workflowString).toBe("spec â†’ exec â†’ qa");
      });

      it("parses phases with test phase", () => {
        const body = "spec â†’ exec â†’ test â†’ qa";
        const result = parseSolveWorkflow(body);
        expect(result.phases).toEqual(["spec", "exec", "test", "qa"]);
      });

      it("parses phases with testgen phase", () => {
        const body = "spec â†’ testgen â†’ exec â†’ qa";
        const result = parseSolveWorkflow(body);
        expect(result.phases).toEqual(["spec", "testgen", "exec", "qa"]);
      });

      it("parses phases with security-review phase", () => {
        const body = "spec â†’ exec â†’ security-review â†’ qa";
        const result = parseSolveWorkflow(body);
        expect(result.phases).toEqual([
          "spec",
          "exec",
          "security-review",
          "qa",
        ]);
      });

      it("parses full workflow with testgen and test", () => {
        const body = "spec â†’ testgen â†’ exec â†’ test â†’ qa";
        const result = parseSolveWorkflow(body);
        expect(result.phases).toEqual([
          "spec",
          "testgen",
          "exec",
          "test",
          "qa",
        ]);
      });

      it("parses ASCII arrow notation", () => {
        const body = "spec -> exec -> qa";
        const result = parseSolveWorkflow(body);
        expect(result.phases).toEqual(["spec", "exec", "qa"]);
      });

      it("parses slash command notation from individual lines", () => {
        const body = `/spec 123
/exec 123
/qa 123`;
        const result = parseSolveWorkflow(body);
        expect(result.phases).toEqual(["spec", "exec", "qa"]);
      });

      it("deduplicates phases", () => {
        const body = "spec â†’ exec â†’ spec â†’ qa";
        const result = parseSolveWorkflow(body);
        expect(result.phases).toEqual(["spec", "exec", "qa"]);
      });

      it("handles phases embedded in workflow line", () => {
        const body =
          "#123  Add feature Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· ui â†’ spec â†’ testgen â†’ exec â†’ test â†’ qa";
        const result = parseSolveWorkflow(body);
        expect(result.phases).toContain("spec");
        expect(result.phases).toContain("testgen");
        expect(result.phases).toContain("exec");
        expect(result.phases).toContain("test");
        expect(result.phases).toContain("qa");
      });
    });

    describe("issue number extraction", () => {
      it("extracts single issue number", () => {
        const body = "## Solve Workflow for Issue: 123\nspec â†’ exec â†’ qa";
        const result = parseSolveWorkflow(body);
        expect(result.issueNumbers).toEqual([123]);
      });

      it("extracts multiple issue numbers", () => {
        const body = "## Solve Workflow for Issues: 123, 456, 789\nspec â†’ exec";
        const result = parseSolveWorkflow(body);
        expect(result.issueNumbers).toEqual([123, 456, 789]);
      });

      it("extracts issue numbers with hash prefix", () => {
        const body = "## Solve Workflow for Issues: #123, #456\nspec â†’ exec";
        const result = parseSolveWorkflow(body);
        expect(result.issueNumbers).toEqual([123, 456]);
      });

      it("deduplicates issue numbers", () => {
        const body = "## Solve Workflow for Issues: 123, 123, 456\nspec â†’ exec";
        const result = parseSolveWorkflow(body);
        expect(result.issueNumbers).toEqual([123, 456]);
      });

      it("returns empty array when no header found", () => {
        const body = "spec â†’ exec â†’ qa";
        const result = parseSolveWorkflow(body);
        expect(result.issueNumbers).toEqual([]);
      });
    });

    describe("quality loop detection", () => {
      it("detects quality loop auto-enable", () => {
        const body = "spec â†’ exec â†’ qa\nquality loop auto-enable";
        const result = parseSolveWorkflow(body);
        expect(result.qualityLoop).toBe(true);
      });

      it("detects --quality-loop flag", () => {
        const body = "spec â†’ exec â†’ qa\nUse --quality-loop for iterations";
        const result = parseSolveWorkflow(body);
        expect(result.qualityLoop).toBe(true);
      });

      it("detects quality loop recommended", () => {
        const body = "spec â†’ exec â†’ qa\nquality loop is recommended";
        const result = parseSolveWorkflow(body);
        expect(result.qualityLoop).toBe(true);
      });

      it("detects enable quality loop", () => {
        const body = "spec â†’ exec â†’ qa\nenable quality loop for this";
        const result = parseSolveWorkflow(body);
        expect(result.qualityLoop).toBe(true);
      });

      it("returns false when quality loop not mentioned", () => {
        const body = "spec â†’ exec â†’ qa";
        const result = parseSolveWorkflow(body);
        expect(result.qualityLoop).toBe(false);
      });
    });

    describe("real-world solve output", () => {
      it("parses complete solve comment", () => {
        const body = `## Solve Workflow for Issues: 152, 153

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  npx sequant run 152 153 -q                                  â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

#152  Add user dashboard Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· ui â†’ spec â†’ testgen â†’ exec â†’ test â†’ qa
#153  Refactor auth module Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· backend â†’ spec â†’ exec â†’ qa

â”Œâ”€ Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  -q                 âœ“  quality loop auto-enable              â”‚
â”‚  --chain            âœ—  independent (different codepaths)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜`;

        const result = parseSolveWorkflow(body);
        expect(result.issueNumbers).toEqual([152, 153]);
        expect(result.phases).toContain("spec");
        expect(result.phases).toContain("testgen");
        expect(result.phases).toContain("exec");
        expect(result.qualityLoop).toBe(true);
      });
    });
  });

  describe("solveWorkflowToSignals", () => {
    it("converts phases to signals with solve source", () => {
      const workflow = {
        phases: ["spec" as const, "exec" as const, "qa" as const],
        qualityLoop: false,
        issueNumbers: [123],
        workflowString: "spec â†’ exec â†’ qa",
      };

      const signals = solveWorkflowToSignals(workflow);

      expect(signals).toHaveLength(3);
      expect(signals[0]).toEqual({
        phase: "spec",
        source: "solve",
        confidence: "high",
        reason: "Recommended by /solve command: spec â†’ exec â†’ qa",
      });
    });

    it("includes quality-loop signal when enabled", () => {
      const workflow = {
        phases: ["spec" as const, "exec" as const],
        qualityLoop: true,
        issueNumbers: [123],
      };

      const signals = solveWorkflowToSignals(workflow);

      expect(signals).toHaveLength(3);
      expect(signals[2]).toEqual({
        phase: "quality-loop",
        source: "solve",
        confidence: "high",
        reason: "Quality loop recommended by /solve command",
      });
    });

    it("handles testgen phase", () => {
      const workflow = {
        phases: ["spec" as const, "testgen" as const, "exec" as const],
        qualityLoop: false,
        issueNumbers: [123],
        workflowString: "spec â†’ testgen â†’ exec",
      };

      const signals = solveWorkflowToSignals(workflow);

      expect(signals).toHaveLength(3);
      expect(signals[1].phase).toBe("testgen");
      expect(signals[1].source).toBe("solve");
    });
  });

  describe("solveCoversIssue", () => {
    it("returns true when issue is in list", () => {
      const workflow = {
        phases: [],
        qualityLoop: false,
        issueNumbers: [123, 456],
      };
      expect(solveCoversIssue(workflow, 123)).toBe(true);
      expect(solveCoversIssue(workflow, 456)).toBe(true);
    });

    it("returns false when issue is not in list", () => {
      const workflow = {
        phases: [],
        qualityLoop: false,
        issueNumbers: [123, 456],
      };
      expect(solveCoversIssue(workflow, 789)).toBe(false);
    });

    it("returns false when list is empty", () => {
      const workflow = {
        phases: [],
        qualityLoop: false,
        issueNumbers: [],
      };
      expect(solveCoversIssue(workflow, 123)).toBe(false);
    });
  });
});
